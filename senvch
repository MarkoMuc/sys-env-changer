#!/usr/bin/env python
import argparse, os, getpass
from collections import namedtuple

def check_alias(alias):
    if ':' in alias:
        return False
    elif ' ' in alias:
        return False
    
    return True

def error_call(msg, level=0):
    if level == 0:
        print(f'WARNING: {msg}')
    else:
        print(f'CRITICAL: {msg}')
        exit(-1)

def to_implement(args, path_config):
    print(args)
    print('NOT IMPLEMENTED')

def fill_dictionary(file_path) :
    #For every path in $HOME/.config/senvch/
    env_vars = {}
    
    with open(file_path, 'r') as file:
        lines = file.readlines()

    for i, line in enumerate(lines) :
        parts = line.strip().split('=', 1)
        if len(parts) == 2 :
            var_name = parts[0]
            parts = parts[1].strip().split("#", 1) 
            var_curr_value = parts[0]
            parts = parts[1].strip().split("&&&", 2) 
            if len(parts) == 3 :
                var_script = parts[0]
                var_description = parts[1]
                var_values = parts[2]
                Input = namedtuple('Input',['var_index','var_script', 'var_curr_value', 'var_description', 'var_values'])
                env_vars[var_name] = Input(var_index=i, var_script = var_script, var_curr_value = var_curr_value,
                                        var_description = var_description, var_values = var_values)
            else :
                print("ERROR IN DESCRIPTION!")
                exit(-1)
        else :
            print("ERROR IN VALUE DECLARATION!")
            exit(-1)
    return env_vars

def replace_line(file_path, env_variable, replace_value, line_index):
    
    with open(file_path, 'r') as file:
        lines = file.readlines()

    # If the line was found, replace it
    if line_index is not None:
        descrp = lines[line_index].strip().split('#', 1)
        new_line = f'{env_variable}={replace_value} #{descrp[1]}\n'
        old_line = lines[line_index]
        lines[line_index] = new_line

        # Write the updated content back to the file
        with open(file_path, 'w') as file:
            file.writelines(lines)

        print("Line replaced successfully. Old value : ", old_line)
    else:
        print("Line not found in the file.")

def make_help(env_dict) :
    help_string = ""
    
    for key, value in env_dict.items():
        help_string += f'\t{key} - from: {value.var_script} | current value: {value.var_curr_value} | description : {value.var_description} | values: {value.var_values}.\n'
    
    return help_string

def create_config():
    #Create folder $HOME/.config/senvch
    path_home = os.getenv('HOME', f'/home/{getpass.getuser()}')
    path_home = path_home[:-1] if path_home[- 1] == '/' else path_home 
    path_home += '/.config/senvch'
    if not os.path.isdir(path_home):
        os.makedirs(path_home)
    return path_home + '/paths.cfg'


def command_add(args, path_config):
    # ADD_PATHS is an array with strings in format PATH[:ALIAS]
    print(args)
    contents_config = list()
    if os.path.isfile(path_config):
        contents_config = open(path_config).readlines()
    
    with open(path_config, mode='w+') as config_file:
        for entry in args.add_paths:
            entry = entry.strip()
            add_entry = True
            path_alias = entry.split(':')
            
            if len(path_alias) > 2:
                error_call(f'Entry {entry} not formatted correctly', 0)
                continue
            elif len(path_alias) == 2 and not check_alias(path_alias[1]):
                error_call(f'Alias of entry {entry} not formatted correctly, cannot contain whitespace or ":"', 0)
            elif len(path_alias) == 1:
                entry += ':'
            if not entry.endswith('\n'):
                entry += '\n'

            # Replace alias if needed
            for i, config_entry in enumerate(contents_config):
                if path_alias[0] == config_entry.split(':')[0]:
                    contents_config[i] = entry
                    add_entry = False
                    break

            if add_entry:
                contents_config.append(entry)

        config_file.write("".join(contents_config))


def command_delete(args, path_config):
    print(args)
    contents_config = list()
    if os.path.isfile(path_config):
        contents_config = open(path_config).readlines()
    
    with open(path_config, mode='w+') as config_file:
        if args.delete_paths is not None:
            for entry in args.delete_paths:
                entry = entry.strip()
                delete_entry = False
                
                for i, config_entry in enumerate(contents_config):
                    if entry == config_entry.split(':')[0]:
                        contents_config.remove(config_entry)
                        delete_entry = True
                        break

                if not delete_entry:
                    error_call(f'Path {entry} not found in config file.')

        if args.alias is not None:
            for entry in args.alias:
                if not check_alias(entry):
                    error_call(f'Alias {entry} is not valid.')
                    continue

                entry = entry.strip()
                delete_entry = False
                
                for config_entry in contents_config:
                    if entry == config_entry.split(':')[1].strip():
                        contents_config.remove(config_entry)
                        delete_entry = True

                if not delete_entry:
                    error_call(f'Alias {entry} not found in config file.')
        config_file.write("".join(contents_config))

def command_paths(args, path_config):
    print(args)

    contents_config = list()
    if os.path.isfile(path_config):
        contents_config = open(path_config).readlines()
    
    if args.all:
        print("".join( [entry for entry in contents_config]), end='')
        return
    
    for entry in args.paths_alias:
        entry = entry.strip()
        check_entry = True
        
        if not check_alias(entry):
            error_call(f'Alias {entry} is not valid.')
        
        paths_buffer = [config_entry.split(':')[0] for config_entry in contents_config if config_entry.split(':')[1].strip() == entry]
        
        if len(paths_buffer) > 0:
            print("\n".join(paths_buffer))
        else:
            error_call(f'Paths connected with alias {entry} not found.')

def command_change(args, path_config):
    contents_config = list()
    if not check_alias(args.new) or not check_alias(args.original) or args.original == '':
        error_call(f'Format of alias is not valid, try using add command', 1)

    if os.path.isfile(path_config):
        contents_config = open(path_config).readlines()
    
    with open(path_config, mode='w+') as config_file:
        changed = False
        
        # Replace alias if needed
        for i, config_entry in enumerate(contents_config):
            if args.original == config_entry.split(':')[1].strip():
                contents_config[i] = f'{config_entry.split(':')[0]}:{args.new}\n'
                changed = True

        if changed is False:
            print(f'Alias {args.original} not found.')

        config_file.write("".join(contents_config))

def command_delete_alias(args, path_config):
    print(args)
    for alias in args.alias:
        command_change(type("TempARGS",(),{'original':alias, 'new':''}), path_config)


if __name__ == "__main__":
    path_config = create_config()

    parser = argparse.ArgumentParser(description="Parses arguments to run")

    subparser= parser.add_subparsers(help='Subcommands help.')
    parser_add = subparser.add_parser('add', help='Add path with a possible alias.')
    parser_add.add_argument('add_paths', nargs='+', type=str, 
                        help='Add one or more paths each with an optional alias in format PATH[:ALAIS].')
    parser_add.set_defaults(func=command_add)

    parser_delete = subparser.add_parser('delete', help='Delete alias or path.')
    parser_delete.add_argument('delete_paths', nargs='*', type=str, 
                        help='Delete a path.')
    parser_delete.add_argument('-a', '--alias', nargs='+', type=str, 
                        help='Delete one or more paths by aliases.')
    parser_delete.set_defaults(func=command_delete)

    parser_delete_alias = subparser.add_parser('delalias', help='Delete alias or path.')
    parser_delete_alias.add_argument('alias', nargs='+', type=str, 
                        help='Delete an alias.')
    parser_delete_alias.set_defaults(func=command_delete_alias)
    
    parser_paths = subparser.add_parser('paths', help='List existing paths.')
    parser_paths.add_argument('paths_alias', nargs='*', type=str, 
                             help='List paths associated with an alias.')
    parser_paths.add_argument('-a', '--all', action='store_true', 
                        help='List all paths and their aliases.')
    parser_paths.set_defaults(func=command_paths)
    
    parser_change = subparser.add_parser('change', help='Change an existing alias.')
    parser_change.add_argument('original', type=str, 
                             help='Existing alias.')
    parser_change.add_argument('new', type=str, 
                             help='New alias.')
    parser_change.set_defaults(func=command_change)
    
    parser_vars = subparser.add_parser('vars', help='List environmental variables.')
    parser_vars.add_argument('path_alias', nargs='*',type=str, 
                             help='Path or alias to a file.')
    parser_vars.add_argument('-a', '-all', action='store_true', 
                             help='List all variables in all saved files.')
    parser_vars.set_defaults(func=to_implement)
    
    parser_file = subparser.add_parser('file', help='List environmental variables of an unsaved file.')
    parser_file.add_argument('path', nargs='*',type=str, 
                             help='Path to a file.')
    parser_file.add_argument('-c', '--change', type=str, 
                             help='Change the values of a variable, format: VAR:VALUE .')
    parser_file.set_defaults(func=to_implement)
    
    args = parser.parse_args()
    args.func(args, path_config)

    exit()

    info = env_dict.get(args.variable, "unknown")
    
    if info != "unknown" :
        replace_line(file_path=PATH_TO_FILE, env_variable=args.variable, replace_value=args.value, line_index=info.var_index)
    else :
        print(f'Variable {args.variable} does not exist!')
        exit(-1)
    
    exit(0)
