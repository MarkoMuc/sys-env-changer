#!/usr/bin/env python
import argparse, os, getpass
from collections import namedtuple

PATH_TO_DIR = None

PATH_TO_FILE = "./test/config.sh"

def fill_dictionary(file_path) :
    #For every path in $HOME/.config/senvch/
    env_vars = {}
    
    with open(file_path, 'r') as file:
        lines = file.readlines()

    for i, line in enumerate(lines) :
        parts = line.strip().split('=', 1)
        if len(parts) == 2 :
            var_name = parts[0]
            parts = parts[1].strip().split("#", 1) 
            var_curr_value = parts[0]
            parts = parts[1].strip().split("&&&", 2) 
            if len(parts) == 3 :
                var_script = parts[0]
                var_description = parts[1]
                var_values = parts[2]
                Input = namedtuple('Input',['var_index','var_script', 'var_curr_value', 'var_description', 'var_values'])
                env_vars[var_name] = Input(var_index=i, var_script = var_script, var_curr_value = var_curr_value,
                                        var_description = var_description, var_values = var_values)
            else :
                print("ERROR IN DESCRIPTION!")
                exit(-1)
        else :
            print("ERROR IN VALUE DECLARATION!")
            exit(-1)
    return env_vars

def replace_line(file_path, env_variable, replace_value, line_index):
    
    with open(file_path, 'r') as file:
        lines = file.readlines()

    # If the line was found, replace it
    if line_index is not None:
        descrp = lines[line_index].strip().split('#', 1)
        new_line = f'{env_variable}={replace_value} #{descrp[1]}\n'
        old_line = lines[line_index]
        lines[line_index] = new_line

        # Write the updated content back to the file
        with open(file_path, 'w') as file:
            file.writelines(lines)

        print("Line replaced successfully. Old value : ", old_line)
    else:
        print("Line not found in the file.")

def make_help(env_dict) :
    help_string = ""
    
    for key, value in env_dict.items():
        help_string += f'\t{key} - from: {value.var_script} | current value: {value.var_curr_value} | description : {value.var_description} | values: {value.var_values}.\n'
    
    return help_string

def create_config():
    #Create folder $HOME/.config/senvch
    path_home = os.getenv('HOME', f'/home/{getpass.getuser()}')
    path_home = path_home[:-1] if path_home[- 1] == '/' else path_home 
    path_home += '/.config/senvch'
    if not os.path.isdir(path_home):
        os.makedirs(path_home)
    return path_home + '/paths.cfg'

def command_add(args):
    print(args)

def command_delete(args):
    print(args)

def command_list(args):
    print(args)

def command_change(args):
    print(args)

if __name__ == "__main__":
    path_config = create_config()

    parser = argparse.ArgumentParser(description="Parses arguments to run")

    subparser= parser.add_subparsers(help='Subcommands help.')
    parser_add = subparser.add_parser('add', help='Add path with a possible alias.')
    parser_add.add_argument('add_paths', nargs='+', type=str, 
                        help='Add one or more paths each with an optional alias in format PATH[:ALAIS].')
    parser_add.set_defaults(func=command_add)

    parser_delete = subparser.add_parser('delete', help='Delete alias or path.')
    parser_delete.add_argument('delete_paths', nargs='*', type=str, 
                        help='Delete one or more paths by path or alias.')
    parser_delete.add_argument('-a', '--alias', nargs='+', type=str, 
                        help='Delete one or more aliases.')
    parser_delete.set_defaults(func=command_delete)

    parser_list = subparser.add_parser('list', help='List existing paths.')
    parser_list.add_argument('list_alias', nargs='*', type=str, 
                             help='List one path associated alias.')
    parser_list.add_argument('-l', '--list', action='store_true', 
                        help='List all paths and their aliases.')
    parser_list.set_defaults(func=command_list)
    
    parser_change = subparser.add_parser('change', help='Change an existing alias.')
    parser_change.add_argument('original', type=str, 
                             help='Existing alias.')
    parser_change.add_argument('new', type=str, 
                             help='New alias.')
    parser_change.set_defaults(func=command_change)
    
    args = parser.parse_args()
    args.func(args)

    exit()

    info = env_dict.get(args.variable, "unknown")
    
    if info != "unknown" :
        replace_line(file_path=PATH_TO_FILE, env_variable=args.variable, replace_value=args.value, line_index=info.var_index)
    else :
        print(f'Variable {args.variable} does not exist!')
        exit(-1)
    
    exit(0)
