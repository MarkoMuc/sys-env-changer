#!/usr/bin/env python
import argparse, os, getpass, sys

ENV_DICT = {}

class VariableEntry:
    var_name = ''
    file_path = ''
    associated_file = ''
    var_desc = ''
    value_desc = ''
    var_value = ''

    def __init__(self, var_name, file_path, associated_file='', var_desc='', value_desc='', var_value=''):
        self.var_name = var_name
        self.file_path = file_path
        self.associated_file = associated_file
        self.var_desc = var_desc
        self.value_desc = value_desc
        self.var_value = var_value


def check_alias(alias):
    if ':' in alias:
        return False
    elif ' ' in alias:
        return False
    
    return True


def error_call(msg, level=0):
    if level == 0:
        sys.stderr.write(f'WARNING: {msg.strip()} \n')
    else:
        sys.stderr.write(f'CRITICAL: {msg.strip()} \n')
        exit(level)


def to_implement(args, path_config):
    print(args)
    print('NOT IMPLEMENTED')


def fill_dictionary(target) :
    env_vars = {}
    
    for file_path in target:
        if not os.path.isfile(file_path):
            error_call(f'Path {file_path} does not exist.')
            continue
         
        for i, entry in enumerate(open(file_path, 'r').readlines()):
            var_name = ''
            associated_file = ''
            var_desc = ''
            value_desc = ''
            var_value = ''
            
            split_entry = entry.split('#')
            if len(split_entry) == 0:
                error_call(f'Line {i} in {file_path} is not formatted correctly.')
                continue

            split_var = split_entry[0].split('=')

            if len(split_var) > 2:
                error_call(f'Line {i} in {file_path} is not formatted correctly.')
                split_var[1] = "=".join(split_var[1:]) 
            elif len(split_var) == 1:
                var_name = split_var[0].strip()
            
            var_name = split_var[0].strip()
            var_value = split_var[1].strip()
            
            if len(split_entry) == 1:
                error_call(f'Line {i} in {file_path} has no description.')
            elif len(split_entry) > 2:
                split_entry[1] = "#".join(split_entry[1:])
                error_call(f'Line {i} in {file_path} is not formatted correctly.')

            split_desc = split_entry[1].split('&&&')

            if len(split_desc) > 3:
                error_call(f'Line {i} in {file_path} is not formatted correctly.')
                
            if len(split_desc) == 3:
                associated_file = split_desc[0].strip()
                var_desc = split_desc[1].strip()
                value_desc = split_desc[2].strip()
            elif len(split_desc) == 2:
                error_call(f'Line {i} in {file_path} is not formatted correctly.')
                associated_file = split_desc[0].strip()
                var_desc = split_desc[1].strip()
            else:
                error_call(f'Line {i} in {file_path} is not formatted correctly.')
                associated_file = split_desc[0].strip()
            env_vars[var_name] = VariableEntry(var_name, file_path, associated_file, var_desc, value_desc, var_value)
    return env_vars


def replace_line(file_path, env_variable, replace_value, line_index):
    
    with open(file_path, 'r') as file:
        lines = file.readlines()

    # If the line was found, replace it
    if line_index is not None:
        descrp = lines[line_index].strip().split('#', 1)
        new_line = f'{env_variable}={replace_value} #{descrp[1]}\n'
        old_line = lines[line_index]
        lines[line_index] = new_line

        # Write the updated content back to the file
        with open(file_path, 'w') as file:
            file.writelines(lines)

        print("Line replaced successfully. Old value : ", old_line)
    else:
        print("Line not found in the file.")



def create_config():
    #Create folder $HOME/.config/senvch
    path_home = os.getenv('HOME', f'/home/{getpass.getuser()}')
    path_home = path_home[:-1] if path_home[- 1] == '/' else path_home 
    path_home += '/.config/senvch'
    if not os.path.isdir(path_home):
        os.makedirs(path_home)
    return path_home + '/paths.cfg'


def command_add(args, path_config):
    # ADD_PATHS is an array with strings in format PATH[:ALIAS]
    print(args)
    contents_config = list()
    if os.path.isfile(path_config):
        contents_config = open(path_config).readlines()
    
    with open(path_config, mode='w+') as config_file:
        for entry in args.add_paths:
            entry = entry.strip()
            add_entry = True
            path_alias = entry.split(':')
            
            if len(path_alias) > 2:
                error_call(f'Entry {entry} not formatted correctly', 0)
                continue
            elif len(path_alias) == 2 and not check_alias(path_alias[1]):
                error_call(f'Alias of entry {entry} not formatted correctly, cannot contain whitespace or ":"', 0)
            elif len(path_alias) == 1:
                entry += ':'
            if not entry.endswith('\n'):
                entry += '\n'

            # Replace alias if needed
            for i, config_entry in enumerate(contents_config):
                if path_alias[0] == config_entry.split(':')[0]:
                    contents_config[i] = entry
                    add_entry = False
                    break

            if add_entry:
                contents_config.append(entry)

        config_file.write("".join(contents_config))


def command_delete(args, path_config):
    print(args)
    contents_config = list()
    if os.path.isfile(path_config):
        contents_config = open(path_config).readlines()
    
    with open(path_config, mode='w+') as config_file:
        if args.delete_paths is not None:
            for entry in args.delete_paths:
                entry = entry.strip()
                delete_entry = False
                contents = contents_config[:]
                for i, config_entry in enumerate(contents):
                    if entry == config_entry.split(':')[0]:
                        contents_config.remove(config_entry)
                        delete_entry = True
                        break

                if not delete_entry:
                    error_call(f'Path {entry} not found in config file.')

        if args.alias is not None:
            for entry in args.alias:
                if not check_alias(entry):
                    error_call(f'Alias {entry} is not valid.')
                    continue

                entry = entry.strip()
                delete_entry = False
                
                contents = contents_config[:]
                for config_entry in contents_config:
                    if entry.strip() == config_entry.split(':')[1].strip():
                        contents_config.remove(config_entry)
                        delete_entry = True

                if not delete_entry:
                    error_call(f'Alias {entry} not found in config file.')
        config_file.write("".join(contents_config))


def command_paths(args, path_config):
    print(args)
    contents_config = list()
    if os.path.isfile(path_config):
        contents_config = open(path_config).readlines()
    
    if args.all:
        if args.only_alias:
            print("".join(set([entry.split(':')[1] for entry in contents_config if '' != entry.split(':')[1].strip()])), end='')
        else:
            print("".join( [entry for entry in contents_config]), end='')
        return
    
    for entry in args.paths_alias:
        entry = entry.strip()
        check_entry = True
        
        if not check_alias(entry):
            error_call(f'Alias {entry} is not valid.')
        
        paths_buffer = [config_entry.split(':')[0] for config_entry in contents_config if config_entry.split(':')[1].strip() == entry]
        
        if len(paths_buffer) > 0:
            print("\n".join(paths_buffer))
        else:
            error_call(f'Paths connected with alias {entry} not found.')


def command_change(args, path_config):
    contents_config = list()
    if not check_alias(args.new) or not check_alias(args.original) or args.original == '':
        error_call(f'Format of alias is not valid, try using add command', 1)

    if os.path.isfile(path_config):
        contents_config = open(path_config).readlines()
    
    with open(path_config, mode='w+') as config_file:
        changed = False
        
        # Replace alias if needed
        for i, config_entry in enumerate(contents_config):
            if args.original == config_entry.split(':')[1].strip():
                contents_config[i] = f'{config_entry.split(':')[0]}:{args.new}\n'
                changed = True

        if changed is False:
            error_call(f'Alias {args.original} not found.')

        config_file.write("".join(contents_config))


def command_delete_alias(args, path_config):
    print(args)
    for alias in args.alias:
        command_change(type("TempARGS",(),{'original':alias, 'new':''}), path_config)


def command_vars(args, path_config):
    print(args)
    path_set = set()
    if os.path.isfile(path_config):
        contents_config = open(path_config).readlines()

    if args.all:
        path_set = set([entry.split(':')[0].strip() for entry in contents_config])
    for entry in args.path_alias:
        found = False
        if os.path.isfile(entry):
            for cont_entry in contents_config:
                if cont_entry.split(':')[0] == entry:
                    path_set.add(entry)
                    found = True
        else:
            for cont_entry in contents_config:
                if cont_entry.split(':')[1].strip() == entry:
                    path_set.add(cont_entry.split(':')[0].strip())
                    found = True

        if not found:
            error_call(f'Path or alias {entry} not found.')
    
    target = fill_dictionary(path_set)
    
    for entry in target.values():
        if args.verbose == 4: 
            print(f'[from:{entry.file_path}, for:{entry.associated_file}]; {entry.var_name} = {entry.var_value}| desc: {entry.var_desc}, possible:{entry.value_desc}')
        elif args.verbose == 3:
            print(f'[for:{entry.associated_file}]; {entry.var_name} = {entry.var_value}| desc: {entry.var_desc}, possible:{entry.value_desc}')
        elif args.verbose == 2:
            print(f'[for:{entry.associated_file}]; {entry.var_name} = {entry.var_value}| possible:{entry.value_desc}')
        elif args.verbose == 1:
            print(f'[for:{entry.associated_file}]; {entry.var_name} = {entry.var_value}')
        elif args.verbose == 0:
            print(f'{entry.var_name} = {entry.var_value}')


if __name__ == "__main__":
    path_config = create_config()

    parser = argparse.ArgumentParser(description="Parses arguments to run")

    subparser= parser.add_subparsers(help='Subcommands help.')
    parser_add = subparser.add_parser('add', help='Add path with a possible alias.')
    parser_add.add_argument('add_paths', nargs='+', type=str, 
                        help='Add one or more paths each with an optional alias in format PATH[:ALAIS].')
    parser_add.set_defaults(func=command_add)

    parser_delete = subparser.add_parser('delete', help='Delete alias or path.')
    parser_delete.add_argument('delete_paths', nargs='*', type=str, 
                        help='Delete a path.')
    parser_delete.add_argument('-a', '--alias', nargs='+', type=str, 
                        help='Delete one or more paths by aliases.')
    parser_delete.set_defaults(func=command_delete)

    parser_delete_alias = subparser.add_parser('delalias', help='Delete alias.')
    parser_delete_alias.add_argument('alias', nargs='+', type=str, 
                        help='Delete an alias.')
    parser_delete_alias.set_defaults(func=command_delete_alias)
    
    parser_paths = subparser.add_parser('paths', help='List existing paths.')
    parser_paths.add_argument('paths_alias', nargs='*', type=str, 
                             help='List paths associated with an alias.')
    parser_paths.add_argument('-a', '--all', action='store_true', 
                        help='List all paths and their aliases.')
    parser_paths.add_argument('-o', '--only-alias', action='store_true', 
                        help='List all aliases.')

    parser_paths.set_defaults(func=command_paths)
    
    parser_change = subparser.add_parser('change', help='Change an existing alias.')
    parser_change.add_argument('original', type=str, 
                             help='Existing alias.')
    parser_change.add_argument('new', type=str, 
                             help='New alias.')
    parser_change.set_defaults(func=command_change)
    
    parser_vars = subparser.add_parser('vars', help='List environmental variables.')
    parser_vars.add_argument('path_alias', nargs='*',type=str, 
                             help='Path or alias to a file.')
    parser_vars.add_argument('-a', '--all', action='store_true', 
                             help='List all variables in all saved files.')
    parser_vars.add_argument('-v', '--verbose', choices = range(0,5), type=int, default=0, 
                             help='List all variables in all saved files.')

    parser_vars.set_defaults(func=command_vars)
    
    parser_file = subparser.add_parser('file', help='List environmental variables of an unsaved file.')
    parser_file.add_argument('path', nargs='*',type=str, 
                             help='Path to a file.')
    parser_file.add_argument('-c', '--change', type=str, 
                             help='Change the values of a variable, format: VAR:VALUE .')
    parser_file.set_defaults(func=to_implement)
    
    args = parser.parse_args()
    args.func(args, path_config)
    
    exit(0)
